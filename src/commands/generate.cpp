#include "convoy/commands/generate.h"

#include <algorithm>
#include <array>
#include <chrono>
#include <cstdio>
#include <iostream>
#include <fstream>
#include <memory>
#include <vector>

using namespace commands;

static std::vector<std::filesystem::path> GetFilesToCompile(std::filesystem::path path)
{
    std::vector<std::filesystem::path> files;

    for (const auto& it: std::filesystem::recursive_directory_iterator(path))
    {
        const auto& path = it.path();
        if (path.extension() == ".cpp")
        {
            files.emplace_back(path);
        }
    }

    return files;
}

static void GenerateNinjaBuildFiles(std::filesystem::path path, std::filesystem::path target, std::filesystem::path profile)
{
    if (path == ".")
    {
        path = std::filesystem::current_path();
    }

    std::string outputPathString = (target / profile / path.stem()).string();
    std::replace(outputPathString.begin(), outputPathString.end(), '\\', '/');

    const auto buildFile = path / "build.ninja";
    std::ofstream file { buildFile };
    if (file.is_open())
    {
        file << "# Autogenerated by convoy\n\n"
            << "ninja_required_version = 1.10\n"
            << "\n"
            << "root = .\n"
            << "builddir = build\n"
            << "cxx = clang++\n"
            << "cflags = -std=c++17 -Wall -Wextra -Wpedantic -Iinclude/ -Isrc/\n"
            << "ldflags = -L$builddir\n"
            << "\n"
            << "rule cxx\n"
            << "  command = $cxx $cflags -c $in -o $out\n"
            << "\n"
            << "rule link\n"
            << "  command = $cxx $ldflags $in -o $out\n"
            << "\n";

        std::vector<std::filesystem::path> srcFiles = GetFilesToCompile(path / "src");
        for (const std::filesystem::path& srcFile: srcFiles)
        {
            std::string srcFileRelativePathString = std::filesystem::relative(srcFile, path / "src").string();
            std::replace(srcFileRelativePathString.begin(), srcFileRelativePathString.end(), '\\', '/');

            std::string objFileRelativePathString = std::filesystem::relative(srcFile, path / "src").replace_extension(".o").string();
            std::replace(objFileRelativePathString.begin(), objFileRelativePathString.end(), '\\', '/');

            file << "build $builddir/" << objFileRelativePathString << ": cxx $root/src/" << srcFileRelativePathString << "\n";
        }
        file << "\n";


        file << "build " << outputPathString;
#ifdef _WIN32
        file << ".exe";
#endif // _WIN32
        file << ": link $\n";
        for (const std::filesystem::path& srcFile: srcFiles)
        {
            std::string objFileRelativePathString = std::filesystem::relative(srcFile, path / "src").replace_extension(".o").string();
            std::replace(objFileRelativePathString.begin(), objFileRelativePathString.end(), '\\', '/');

            file << "  $builddir/" << objFileRelativePathString << " $\n";
        }
        file << "\n";

        file << "default " << outputPathString;
#ifdef _WIN32
        file << ".exe\n";
#else // !_WIN32
        file << "\n";
#endif // _WIN32
        file << "\n";

        file << "build all: phony " << outputPathString;
#ifdef _WIN32
        file << ".exe\n";
#else // !_WIN32
        file << "\n";
#endif // _WIN32

        file.close();
    }
}

void Generate::Execute(std::string buildSystem, std::filesystem::path path, std::filesystem::path target /*= "bin"*/, std::filesystem::path profile /*= "debug"*/)
{
    if (buildSystem == "ninja")
    {
        GenerateNinjaBuildFiles(path, target, profile);
    }
    else
    {
        std::cerr << "convoy: build system generator for '" << buildSystem << "' not supported!" << std::endl;
        return;
    }
}
